<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>Labirinto com L√≥gica de Programa√ß√£o</title>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', sans-serif;
            background: #eef2f5;
            color: #333;
            overflow: hidden;
        }

        /* HEADER */
        header {
            position: absolute;
            top: 10px;
            left: 2.5%;
            width: 95%;
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            z-index: 100;
            box-sizing: border-box;
            padding: 0 20px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            min-width: 100px;
            justify-content: flex-end;
        }

        #levelButtons {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-grow: 1;
            margin: 0 20px;
            flex-wrap: wrap;
        }

        .level-btn {
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            background-color: #f0f2f5;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            color: #555;
            transition: all 0.2s;
            font-size: 14px;
            padding: 0;
        }

        .level-btn:hover {
            background-color: #e0e0e0;
            transform: scale(1.1);
        }

        .level-btn.active {
            background-color: #42A5F5;
            color: white;
            border-color: #42A5F5;
            box-shadow: 0 3px 8px rgba(66, 165, 245, 0.4);
            transform: scale(1.15);
        }

        #blockCounter {
            font-weight: bold;
            color: #555;
            font-size: 17px;
            min-width: 80px;
            text-align: right;
        }

        .limit-exceeded {
            color: #d32f2f !important;
        }

        /* CONTAINER */
        #container {
            position: absolute;
            top: 80px;
            bottom: 20px;
            left: 2.5%;
            right: 2.5%;
            background: #eef2f5;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 15px;
        }

        #leftPanel {
            flex: 4;
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #ddd;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #rightPanel {
            flex: 6;
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #ddd;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            height: 40px;
            background-color: #f0f4f8;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            padding-left: 20px;
            font-weight: bold;
            color: #555;
            font-size: 14px;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        #gameArea {
            flex-grow: 1;
            position: relative;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #mapWrapper {
            position: relative;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            background: white;
        }

        #blocklyDiv {
            width: 100%;
            flex-grow: 1;
            background-color: #fff;
            position: relative;

        }

        /* CONTROLS */
        #controls {
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f9f9f9;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
            gap: 10px;
        }

        button {
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            transition: transform 0.1s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: scale(0.98);
        }

        #btnRun {
            background: #42A5F5;
            color: white;
        }

        #btnReset {
            background: #EF5350;
            color: white;
        }

        #btnRun, #btnReset {
            position: static; 
            width: 200px;
        }

        /* GAME ASSETS - SpriteSheet */
        .cell {
            position: absolute;
            width: 50px;
            height: 50px;
            border: none;
            box-sizing: border-box;

            background-size: cover; 
            background-repeat: no-repeat;
            image-rendering: pixelated;
        }

        .path { background-image: url('./Sprites/path.png'); }
        .wall { background-image: url('./Sprites/wall.png'); }
        .trap { background-image: url('./Sprites/trap.png'); }
        .outer { background-image: url('./Sprites/outer.png'); }
        .start { background-image: url('./Sprites/start.png'); }

        .goal { 
            background-image: url('./Sprites/end.png'); 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0;
            color: transparent;
        }

        #player {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #eeff00;
            border-radius: 8px;
            transition: all 0.2s linear;
            z-index: 10;
            top: 5px;
            left: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #player::after {
            content: '‚ñ≤';
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            transform: rotate(90deg);
        }

        /* CARD-INFO */
        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .tutorial-box {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 500px;
            max-width: 90%;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            animation: popIn 0.3s ease;
        }

        .tutorial-box h2 {
            margin-top: 0;
            color: #2196F3;
        }

        .tutorial-box p {
            font-size: 18px;
            line-height: 1.5;
            color: #444;
        }

        .tutorial-box button {
            background: #4CAF50;
            color: white;
            margin-top: 20px;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            50% {
                transform: translateX(5px);
            }

            75% {
                transform: translateX(-5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        @keyframes gentle-shake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(3deg); }
            75% { transform: rotate(-3deg); }
        }

        .shake-error {
            animation: shake 0.4s ease-in-out;
            background-color: #d32f2f !important;
            box-shadow: 0 0 10px #d32f2f !important;
        }

        .shake-success {
            animation: shake 0.5s ease-in-out;
            background-color: #388E3C !important;
            box-shadow: 0 0 10px #388E3C !important;
            transform: scale(1.1);
        }

        .shake-constant {
            animation: gentle-shake 0.3s infinite ease-in-out !important;
        }

        #btnHint {
            position: absolute;
            top: 50px;
            left: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            border: 2px solid #ddd;
            color: #2196F3;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            z-index: 500;
            /* Para ficar acima do mapa e do player */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        #btnHint:hover {
            transform: scale(1.1);
            border-color: #2196F3;
        }

        #btnNewBlock {
            position: absolute;
            top: 50px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 20px;
            background: #fffb1d;
            border: 2px solid #d6d316;
            color: black;
            font-size: 17px;
            font-weight: bold;
            cursor: pointer;
            z-index: 500;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
            display: none;
        }

        #btnNewBlock:hover {
            transform: scale(1.1);
            background: #f7f30e;
        }
    </style>
</head>

<body>

    <div id="tutorialOverlay">
        <div class="tutorial-box">
            <h2 id="tutorialTitle">Info</h2>
            <p id="tutorialText">...</p>
            <button onclick="closeTutorial()">Entendi</button>
        </div>
    </div>

    <header>
        <h1>Labirinto</h1>
        <div id="levelButtons"></div>
        <div class="status-bar">
            <div id="blockCounter">Blocos: 0/0</div>
        </div>
    </header>

    <div id="container">
        <div id="leftPanel">
            <div class="panel-header">Labirinto</div>
            
            <button id="btnHint" onclick="openHint()">?</button>
            <button id="btnNewBlock" onclick="openNewBlockInfo()">Bloco Novo!</button>
            
            <div id="gameArea"></div>
        </div>

        <div id="rightPanel">
            <div class="panel-header">√Årea de Montagem</div>
            
            <div id="blocklyDiv"></div>

            <div id="controls">
                <button id="btnRun" onclick="runCode()">‚ñ∂ Executar</button>
                <button id="btnReset" onclick="resetLevel()" style="display: none;">‚Üª Reiniciar</button>
            </div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 50;

        // --- DESIGN DE N√çVEIS ---
        const levels = [
            {
                name: "1",
                // Objetivo: Entender os blocos b√°sicos.
                map: [
                    [1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 3, 1],
                    [1, 1, 1, 1, 0, 1],
                    [1, 2, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1]],
                startPos: { x: 1, y: 3 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right"], maxBlocks: 6,
                tutorial: { title: "N√≠vel 1", text: "Bem-vindo ao labirinto! Use os blocos <b>Avan√ßar</b>, <b>Virar Esquerda</b> e <b>Virar Direita</b> para chegar ate o fim (üü©)." },
                newBlock: {
                    title: "Bem Vindo!",
                    text: "Para mover o personagem pelo labirinto, arraste os blocos de comando <b>Avan√ßar</b>, <b>Virar Esquerda</b> e <b>Virar Direita</b> para a √Årea de Montagem, e monte um c√≥digo que leve o personagem at√© o objetivo (üü©). Boa sorte!"
                }
            },
            {
                name: "2",
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
                startPos: { x: 1, y: 1 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right"], maxBlocks: 5,
                tutorial: { title: "N√≠vel 2", text: "Esse parece at√© mais facil do que o primeiro." }
            },
            {
                name: "3",
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
                startPos: { x: 1, y: 1 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal"], maxBlocks: 2,
                tutorial: { title: "N√≠vel 3", text: "Esse √© parecido com o √∫ltimo, mas voc√™ pode usar o bloco <b>Repetir at√© chegar em üü©</b> para facilitar." },
                newBlock: {
                    title: "Bloco Repetir",
                    text: "O bloco <b>Repetir at√© chegar em üü©</b> permite que voc√™ crie uma repeti√ß√£o que executa os comandos dentro dele at√© que o personagem alcance o objetivo (üü©)."
                }
            },
            {
                name: "4",
                // O Escad√£o: Exige um loop de movimento e virada
                map: [
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 3, 1],
                    [1, 1, 1, 1, 0, 0, 1],
                    [1, 1, 1, 0, 0, 1, 1],
                    [1, 1, 0, 0, 1, 1, 1],
                    [1, 2, 0, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1, y: 5 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal"], maxBlocks: 5,
                tutorial: { title: "N√≠vel 4", text: "Uma escada! Voc√™ consegue criar um padr√£o de movimentos que se repete para subir?" }
            },
            {
                name: "5",
                map: [
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 1, 1, 1],
                    [1, 1, 1, 0, 1, 1, 1],
                    [1, 1, 1, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                ],
                startPos: { x: 1, y: 1 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal", "if_path"], maxBlocks: 6,
                tutorial: { title: "N√≠vel 5", text: "Agora as coisas est√£o ficando interessantes! Use o bloco <b>Se existe caminho √†</b> para se mover na dire√ß√£o correta." },
                newBlock: {
                    title: "Bloco Condicional",
                    text: "O bloco <b>Se existe caminho √†</b> permite que voc√™ verifique se existe um caminho livre em uma dire√ß√£o espec√≠fica (frente, esquerda ou direita). Se o caminho existir, os comandos dentro do bloco ser√£o executados."
                }
            },
            {
                name: "6",
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 3, 0, 0, 0, 1, 1, 1],
                    [1, 1, 1, 1, 0, 1, 1, 1],
                    [1, 1, 4, 1, 0, 0, 4, 1],
                    [1, 1, 0, 1, 0, 1, 1, 1],
                    [1, 2, 0, 0, 0, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
                startPos: { x: 1, y: 5 }, startDir: 1,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal", "if_path", "if_else_path"], maxBlocks: 5,
                tutorial: { title: "N√≠vel 6", text: "Cuidado com as armadilhas. A l√≥gica √© parecida com o ultimo, mas voc√™ pode facilitar o trabalho usando o bloco <b>Se existe caminho √† ... Se n√£o.</b>" },
                newBlock: {
                    title: "Bloco Condicional com Se n√£o",
                    text: "O bloco <b>Se existe caminho √† ... Se n√£o</b> permite que voc√™ verifique se existe um caminho livre em uma dire√ß√£o espec√≠fica (frente, esquerda ou direita). Se o caminho existir, os comandos dentro do primeiro bloco ser√£o executados; caso n√£o exista caminho, os comandos dentro do bloco 'Se n√£o' ser√£o executados."
                }
            },
            {
                name: "7",
                // O Labirinto Cego: Exige verificar laterais
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 3, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1],
                    [1, 2, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1, y: 5 }, startDir: 0,
                blocks: ["move_forward", "turn_left", "turn_right", "repeat_until_goal", "if_else_path"], maxBlocks: 6,
                tutorial: { title: "N√≠vel 7", text: "Labirinto complexo. Sera que um bloco de condi√ß√£o √© o suficiente?" }
            }

        ];

        let currentLevelIndex = 0;
        let map = [], playerPos = { x: 0, y: 0 }, playerDir = 1, commandQueue = [], isRunning = false;
        let simPos = { x: 0, y: 0 }, simDir = 1, protectionCounter = 0, simHitWall = false;
        let animationTimer = null;

        // Blockly Defs
        Blockly.defineBlocksWithJsonArray([
            { "type": "move_forward", "message0": "Avan√ßar ‚¨Ü", "previousStatement": null, "nextStatement": null, "colour": 160, },
            { "type": "turn_left", "message0": "Virar Esquerda ‚¨Ö", "previousStatement": null, "nextStatement": null, "colour": 160 },
            { "type": "turn_right", "message0": "Virar Direita ‚Æï", "previousStatement": null, "nextStatement": null, "colour": 160 },
            { "type": "repeat_until_goal", "message0": "Repetir at√© chegar em üü© %1 %2", "args0": [{ "type": "input_dummy" }, { "type": "input_statement", "name": "DO" }], "previousStatement": null, "nextStatement": null, "colour": 290 },

            {
                "type": "if_path",
                "message0": "Se existe caminho √† %1 %2 %3",
                "args0": [
                    {
                        "type": "field_dropdown",
                        "name": "DIR",
                        "options": [
                            ["frente ‚¨Ü", "ahead"],
                            ["esquerda ‚¨Ö", "left"],
                            ["direita ‚Æï", "right"]
                        ]
                    },
                    { "type": "input_dummy" },
                    { "type": "input_statement", "name": "DO" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": 210
            },
            {
                "type": "if_else_path",
                "message0": "Se existe caminho √† %1 %2 %3 se n√£o %4",
                "args0": [
                    {
                        "type": "field_dropdown",
                        "name": "DIR",
                        "options": [
                            ["frente ‚¨Ü", "ahead"],
                            ["esquerda ‚¨Ö", "left"],
                            ["direita ‚Æï", "right"]
                        ]
                    },
                    { "type": "input_dummy" },
                    { "type": "input_statement", "name": "DO" },
                    { "type": "input_statement", "name": "ELSE" }
                ],
                "previousStatement": null, "nextStatement": null, "colour": 210
            }
        ]);

        javascript.javascriptGenerator.forBlock['move_forward'] = function (block) { return 'simulationMove("' + block.id + '");\n'; };
        javascript.javascriptGenerator.forBlock['turn_left'] = function (block) { return 'simulationTurn(-1, "' + block.id + '");\n'; };
        javascript.javascriptGenerator.forBlock['turn_right'] = function (block) { return 'simulationTurn(1, "' + block.id + '");\n'; };
        javascript.javascriptGenerator.forBlock['repeat_until_goal'] = function (block) {
            var branch = javascript.javascriptGenerator.statementToCode(block, 'DO');
            return 'while (!simulationIsGoal() && !simHitWall && ++protectionCounter < 2000) {\n' + branch + '}\n';
        };
        javascript.javascriptGenerator.forBlock['if_path'] = function (block) {
            var dropdown_dir = block.getFieldValue('DIR'); // Pega o valor selecionado
            var branch = javascript.javascriptGenerator.statementToCode(block, 'DO');
            // Passamos o valor (ex: 'left') para a fun√ß√£o JS
            return 'if (simulationPath("' + dropdown_dir + '")) {\n' + branch + '}\n';
        };

        javascript.javascriptGenerator.forBlock['if_else_path'] = function (block) {
            var dropdown_dir = block.getFieldValue('DIR');
            var branch = javascript.javascriptGenerator.statementToCode(block, 'DO');
            var branchElse = javascript.javascriptGenerator.statementToCode(block, 'ELSE');
            return 'if (simulationPath("' + dropdown_dir + '")) {\n' + branch + '} else {\n' + branchElse + '}\n';
        };

        const workspace = Blockly.inject('blocklyDiv', {
            toolbox: { "kind": "flyoutToolbox", "contents": [] },
            maxBlocks: Infinity,
            scrollbars: true,
            trashcan: true,
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0,
                maxScale: 3,
                minScale: 0.6,
                scaleSpeed: 1.2
            }
        });

        // Resize handler
        function onResize() {
            Blockly.svgResize(workspace);
        }
        window.addEventListener('resize', onResize, false);
        setTimeout(onResize, 100);

        workspace.addChangeListener(() => updateBlockCounter());

        const levelContainer = document.getElementById("levelButtons");

        levels.forEach((lvl, index) => {
            let btn = document.createElement("button");
            btn.className = "level-btn";
            btn.innerText = index + 1;
            btn.title = lvl.name;
            btn.onclick = () => loadLevel(index);
            levelContainer.appendChild(btn);
        });

        function loadLevel(index) {
            if (index >= levels.length) { alert("PARAB√âNS! VOC√ä ZEROU TUDO!"); index = 0; }
            currentLevelIndex = index;

            const buttons = document.querySelectorAll('.level-btn');
            buttons.forEach((btn, i) => {
                if (i === index) {
                    btn.classList.add('active');
                    btn.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                } else {
                    btn.classList.remove('active');
                }
            });

            document.getElementById('btnRun').style.display = 'inline-block';
            document.getElementById('btnReset').style.display = 'none';

            const tutBtn = document.querySelector('.tutorial-box button');
            tutBtn.innerText = 'Entendi';
            tutBtn.onclick = closeTutorial;

            const level = levels[index];
            const btnNewBlock = document.getElementById('btnNewBlock');

            if (level.newBlock) {
                if (index === 0) {
                    btnNewBlock.style.display = 'none'; 
                    btnNewBlock.classList.remove('shake-constant');
                    setTimeout(() => {
                        openNewBlockInfo();
                    }, 500);
                } else {
                    btnNewBlock.style.display = 'block';
                    btnNewBlock.classList.add('shake-constant');
                }
            } else {
                btnNewBlock.style.display = 'none';
                btnNewBlock.classList.remove('shake-constant');
            }

            map = level.map;
            playerPos = { ...level.startPos }; playerDir = level.startDir;
            workspace.options.maxBlocks = level.maxBlocks;
            updateToolbox(level.blocks);
            workspace.clear();
            drawMap();
            resetLevelVariables();
            updateBlockCounter();
            setTimeout(onResize, 50);
        }

        function updateToolbox(allowedBlocks) {
            const toolboxContents = allowedBlocks.map(type => ({ "kind": "block", "type": type }));
            workspace.updateToolbox({ "kind": "flyoutToolbox", "contents": toolboxContents });
        }

        function updateBlockCounter() {
            const max = workspace.options.maxBlocks;
            const used = workspace.getAllBlocks(false).length;
            const counterEl = document.getElementById("blockCounter");
            counterEl.innerText = `Blocos: ${used}/${max}`;
            if (used > max) counterEl.classList.add("limit-exceeded");
            else counterEl.classList.remove("limit-exceeded");
        }

        function showTutorial(tutorialData) {
            if (!tutorialData) return;
            document.getElementById('tutorialTitle').innerText = tutorialData.title;
            document.getElementById('tutorialText').innerHTML = tutorialData.text;
            document.getElementById('tutorialOverlay').style.display = 'flex';
        }
        function closeTutorial() { document.getElementById('tutorialOverlay').style.display = 'none'; }

        const gameArea = document.getElementById('gameArea');
        function drawMap() {
            gameArea.innerHTML = ''; // Limpa s√≥ o mapa
            
            const mapHeightPx = map.length * TILE_SIZE;
            const mapWidthPx = map[0].length * TILE_SIZE;

            const mapWrapper = document.createElement('div');
            mapWrapper.id = 'mapWrapper';
            mapWrapper.style.width = mapWidthPx + 'px';
            mapWrapper.style.height = mapHeightPx + 'px';
            mapWrapper.style.position = 'relative';

            // Cria o Player
            const playerDiv = document.createElement('div');
            playerDiv.id = 'player';
            mapWrapper.appendChild(playerDiv);

            // Cria os Tiles
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    let cell = document.createElement('div');
                    let type = map[y][x];

                    let classType = 'path'; 
                    if (type === 1) classType = 'wall';
                    else if (type === 2) classType = 'start';
                    else if (type === 3) classType = 'goal';
                    else if (type === 4) classType = 'trap';
                    else if (type === 5) classType = 'outer';

                    cell.className = 'cell ' + classType;
                    cell.style.top = (y * TILE_SIZE) + 'px';
                    cell.style.left = (x * TILE_SIZE) + 'px';
                    mapWrapper.appendChild(cell);
                }
            }

            gameArea.appendChild(mapWrapper);
            updatePlayerVisual(playerDiv, playerPos.x, playerPos.y, playerDir);
        }

        function updatePlayerVisual(el, x, y, dir) {
            if (!el) return;
            el.style.top = (y * TILE_SIZE + 5) + 'px';
            el.style.left = (x * TILE_SIZE + 5) + 'px';
            const rotation = (dir * 90) - 90;
            el.style.transform = `rotate(${rotation}deg)`;
        }

        function simulationMove(blockId) {
            if (simHitWall) return;
            let nextX = simPos.x, nextY = simPos.y;
            if (simDir === 0) nextY--;
            if (simDir === 1) nextX++;
            if (simDir === 2) nextY++;
            if (simDir === 3) nextX--;

            if (map[nextY] && map[nextY][nextX] !== undefined) {
                const tileType = map[nextY][nextX];

                if (tileType === 1) {
                    simHitWall = true;
                    commandQueue.push({ action: "bonk", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
                } else if (tileType === 4) {
                    simPos.x = nextX; simPos.y = nextY;
                    commandQueue.push({ action: "move", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
                    simHitWall = true;
                    commandQueue.push({ action: "bonk", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
                } else {
                    simPos.x = nextX; simPos.y = nextY;
                    commandQueue.push({ action: "move", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });

                }
            } else {
                simHitWall = true;
                commandQueue.push({ action: "bonk", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
            }
        }

        function simulationTurn(direction, blockId) {
            if (simHitWall) return;
            if (direction === -1) simDir = (simDir + 3) % 4; else simDir = (simDir + 1) % 4;
            commandQueue.push({ action: "turn", x: simPos.x, y: simPos.y, dir: simDir, blockId: blockId });
        }

        function simulationIsGoal() { return map[simPos.y][simPos.x] === 3; }

        function simulationPath(relativeDir) {
            let checkDir = simDir;
            if (relativeDir === "left") {
                checkDir = (simDir + 3) % 4;
            } else if (relativeDir === "right") {
                checkDir = (simDir + 1) % 4;
            }
            let cx = simPos.x, cy = simPos.y;
            if (checkDir === 0) cy--; // Cima
            if (checkDir === 1) cx++; // Direita
            if (checkDir === 2) cy++; // Baixo
            if (checkDir === 3) cx--; // Esquerda
            return (map[cy] && map[cy][cx] !== 1);
        }

        function runCode() {
            if (isRunning) return;

            stopNewBlockShake();

            if (workspace.getAllBlocks(false).length > workspace.options.maxBlocks) {
                alert(`Limite de blocos excedido!`); return;
            }

            document.getElementById('btnRun').style.display = 'none';
            document.getElementById('btnReset').style.display = 'inline-block';

            resetLevelVariables();
            simPos = { ...playerPos }; simDir = playerDir; protectionCounter = 0; simHitWall = false; isRunning = true;
            const code = javascript.javascriptGenerator.workspaceToCode(workspace);
            try {
                eval(code);
                if (commandQueue.length === 0) isRunning = false; else processQueue();
            } catch (e) { alert("Erro: " + e); isRunning = false; }
        }

        function processQueue() {
            const p = document.getElementById('player');
            if (commandQueue.length === 0) {
                workspace.highlightBlock(null);
                if (map[playerPos.y][playerPos.x] === 3) {
                    p.classList.remove('shake-success');
                    void p.offsetWidth;
                    p.classList.add('shake-success');
                    setTimeout(() => {
                        if (currentLevelIndex + 1 < levels.length) {
                            loadLevel(currentLevelIndex + 1);
                        } else {
                            showVictoryScreen();
                        }
                    }, 1500);
                } else {
                    p.classList.remove('shake-error');
                    void p.offsetWidth;
                    p.classList.add('shake-error');
                }
                isRunning = false; return;
            }
            const cmd = commandQueue.shift();
            if (cmd.blockId) {
                workspace.highlightBlock(cmd.blockId);
            }
            playerPos.x = cmd.x; playerPos.y = cmd.y; playerDir = cmd.dir;
            updatePlayerVisual(p, playerPos.x, playerPos.y, playerDir);
            if (cmd.action === "bonk") {
                p.classList.remove('shake-error');
                void p.offsetWidth;
                p.classList.add('shake-error');
            }
            animationTimer = setTimeout(processQueue, 450);
        }

        function resetLevel() {
            document.getElementById('btnRun').style.display = 'inline-block';
            document.getElementById('btnReset').style.display = 'none';

            resetLevelVariables();
        }

        function resetLevelVariables() {
            if (animationTimer) clearTimeout(animationTimer);

            const level = levels[currentLevelIndex];
            playerPos = { ...level.startPos }; playerDir = level.startDir;
            commandQueue = []; isRunning = false; simHitWall = false;
            const p = document.getElementById('player');
            p.classList.remove('shake-error');
            p.classList.remove('shake-success');
            workspace.highlightBlock(null);
            updatePlayerVisual(document.getElementById('player'), playerPos.x, playerPos.y, playerDir);
        }

        function showVictoryScreen() {
            document.getElementById('tutorialTitle').innerText = "Parab√©ns!";
            document.getElementById('tutorialText').innerHTML = "<b>Voc√™ terminou o jogo!</b><br><br>Voc√™ dominou todos os algoritmos.";

            const btn = document.querySelector('.tutorial-box button');
            btn.innerText = "Voltar ao In√≠cio";
            btn.onclick = function () {
                closeTutorial();
                loadLevel(0);
            };

            document.getElementById('tutorialOverlay').style.display = 'flex';
        }

        function openHint() {
            const tutBtn = document.querySelector('.tutorial-box button');
            tutBtn.innerText = 'Entendi';
            tutBtn.onclick = closeTutorial;

            const tutorialData = levels[currentLevelIndex].tutorial;

            if (tutorialData) {
                showTutorial(tutorialData);
            }
        }

        function openNewBlockInfo() {
            stopNewBlockShake();
            const level = levels[currentLevelIndex];
            if (level.newBlock) {
                document.getElementById('tutorialTitle').innerText = level.newBlock.title;
                document.getElementById('tutorialText').innerHTML = level.newBlock.text;
                
                const tutBtn = document.querySelector('.tutorial-box button');
                tutBtn.innerText = 'Entendi';
                tutBtn.onclick = closeTutorial;
                
                document.getElementById('tutorialOverlay').style.display = 'flex';
            }
        }

        function stopNewBlockShake() {
            const btn = document.getElementById('btnNewBlock');
            if (btn) {
                btn.classList.remove('shake-constant');
            }
        }

        loadLevel(0);
    </script>
</body>

</html>